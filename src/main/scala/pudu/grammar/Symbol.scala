package pudu.grammar


/** Classes to specify grammar symbols. */

sealed trait Symbol

/** Type T refers to the object to be generated by the parser, e.g. an AST node */
class NonTerminal[+T](tag: String) extends Symbol:
  override def toString =
    if tag.isEmpty then super.toString
    else tag

/** It is important to note that values associated with some terminals, like
 *  literals and identifiers, are part of the Token objects generated by the lexer,
 *  and not included in the Terminal class */
class Terminal[+Token <: reflect.Enum](val ordinal: Int, val name: String) extends Symbol:
  override def toString = name

object NonTerminal:
  def apply[T] = new NonTerminal[T]("")
  def apply[T](tag: String) = new NonTerminal[T](tag)

object Terminal:
  inline def apply[T <: reflect.Enum] =
    val (ordinal, name) = enumMetadata[T]
    new Terminal[T](ordinal, name)
  inline def apply[T <: reflect.Enum](name: String) =
    val (ordinal, _) = enumMetadata[T]
    new Terminal[T](ordinal, name)

/* The type of the data associated with a symbol. */
type SymData[T] = T match
  case Terminal[t] => t
  case NonTerminal[t] => t

/* Given a tuple type Tup, SymTuple[Tup] is another
 * tuple type of the same size, where every position that is
 * a subtype of NonTerminal[Tree] is replaced by NonTerminal[Tree],
 * and every position matching Terminal[Token] is replaced by Terminal[Token].
 * In this way, for an arbitrary tuple Tup, Tup <:< SymTuple[Tup] holds
 * if and only if every position of Tup matches either NonTerminal[Tree] or
 * Terminal[Token]. */
type SymTuple[Tree, Token, Tup <: Tuple] = Tup match
  case EmptyTuple => EmptyTuple
  case NonTerminal[Tree] *: xs => NonTerminal[Tree] *: SymTuple[Tree, Token, xs]
  case Terminal[Token] *: xs => Terminal[Token] *: SymTuple[Tree, Token, xs]

/* Matches to true iff T is a subtype of NonTerminal[Tree] or Terminal[Token] */
type IsBounded[Tree, Token, T] = T match
  case NonTerminal[Tree] => true
  case Terminal[Token] => true
